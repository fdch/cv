#!/usr/local/bin/python3
import json, pickle
from pylatex import Document, Section,Subsection, Command, Itemize
from datetime import datetime
from pylatex.base_classes import Environment
from pylatex.utils import NoEscape
from pathlib import Path

MAX_YEAR_LIMIT = 20 # more recent years (with compact flag)
MAX_SHEETS = 8 # range of sheets to pull from (non inclusive)

ENCODING='utf8'

class Itemize(Environment):
    escape = True
    content_separator = "\n"

class Position(Environment):
    escape = True
    content_separator = "\n"

class Resume(Environment):
    escape = True
    content_separator = "\n"

class Quote(Environment):
    escape = True
    content_separator = "\n"

class FlushLeft(Environment):
    escape = True
    content_separator = "\n"

class FlushRight(Environment):
    escape = True
    content_separator = "\n"

def reformat(doc, fmt=None, body=True):

    class Format(Environment):
        escape = True
        content_separator = ""
    if fmt is None:
        fmt = {
                'dates':0,
                'title':0,
                'location':0,
                'employer':0
        }

    with doc.create(Format()):
        doc.append(NoEscape("\\\\\n"))
        for i,j in fmt.items():
            doc.append(Command(i,'r' if j else 'l'))
            doc.append(NoEscape("\\\\\n"))
        if body:
            doc.append(Command("body"))
        doc.append(NoEscape("\n"))

def comment(doc, s=''):
    doc.append(NoEscape("%" + "-"*78 + "\n"))
    doc.append(NoEscape("% "+s+" \n"))
    doc.append(NoEscape("%" + "-"*78 + "\n"))


def writeEntry(doc, item, e):
    dates=e['dates']
    title=e['title']
    employer=e['employer']
    description=e['description']
    location=e['location']
    year=e['year']
    subheader=e['subheader']
    
    if title and title[-1] == ".":
        title[:-2]
    if employer and  employer[-1] == ".":
        employer[:-2]
    if description and description[-1] == ".":
        description[:-2]
    if location and location[-1] == ".":
        location[:-2]

    with doc.create(Itemize(options=[ 
        'align=parleft',
        'leftmargin=2.25cm',
        'labelwidth=2cm' ]
        )):
        doc.append(NoEscape("\\item["+item+"]"))

        if 'ongoing' in dates:
            doc.append(Command('textbf',title))
            doc.append("(ongoing). ")
        else:
            doc.append(Command('textbf',title+"."))
        
        if employer and subheader != employer:
            doc.append(employer+". ")
        
        if description:
            # remove my name from the description if i'm the only one there...
            fd="Federico Camara Halac"
            if fd != description and len(description) != len(fd):
                doc.append(description+". ")
        
        if location:
            doc.append(location+". ")
        
        if 'ongoing' not in dates and dates != year:
            doc.append(dates+".")


if __name__ == '__main__':
    
    import argparse

    parser  = argparse.ArgumentParser()

    parser.add_argument("-u", '--update',
        help="Update local sheet data with google sheet data.", 
        action="store_true")

    parser.add_argument("-c", '--compact',
        help="Make a compact version of the cv", 
        action="store_true")

    parser.add_argument("-p", '--parse',
        help="Parse the local data without fetching it again.", 
        action="store_true")

    args = parser.parse_args()
    
    sheeti  = Path("../data/sheet_id.pkl")
    sheetj  = Path("../data/sheet_data.json")
    sheetp  = Path("../data/sheet_data_parsed.json")
    sheett  = Path("../data/cv_tree.json")
    texfile = Path("../data/temp")
    datafile= Path("../data/data.json")

    if args.compact:
        # do not print the body (description) of each entry
        body = False
    else:
        body = True

    if args.update:

        with sheeti.open(mode='rb') as f:
            sheet_id = pickle.load(f)        

        import download
        download.downloadSheet(sheet_id, sheetj)
    
    if args.update or args.parse:
        
        import parser
        parser.parseSheet(sheetj,sheetp)


    with sheetp.open(mode='r', encoding=ENCODING) as f:
        sheet_data = json.load(f)
    
    with sheett.open(mode='r', encoding=ENCODING) as f:
        cv_tree = json.load(f)

    with datafile.open(mode='r', encoding=ENCODING) as f:
        data = json.load(f)

    doc = Document(
        default_filepath = texfile.as_posix(),
        documentclass    = 'res',
        document_options = ['12pt', 'overlapped'],
        fontenc          = "T1",
        inputenc         = ENCODING,
        font_size        = "normalsize",
        lmodern          = True,
        page_numbers     = False,
        geometry_options = {"tmargin": "1.5cm", "lmargin": "2.5cm"},
    )

    date = str(datetime.date(datetime.now()))
    comment(doc.preamble, "Automatically generated by make on " + date)
    
    print("Making Tex file")

    doc.preamble.append(Command('name', data["personal"]["name"]))
    doc.preamble.append(Command('address', NoEscape("\\\\".join([data["personal"]["phone"], data["personal"]["email"], data["personal"]["website"]]))))
    doc.preamble.append(Command('address', NoEscape(",\\\\".join(data["personal"]["address"]))))
    
    doc.append(Command("raggedright"))
    with doc.create(Resume()):
        for section in cv_tree['sections']:
            sheet=section['sheet']
            with doc.create(Section(sheet_data[sheet]['section'])):
                for v in section['order']:
                    v = v.replace(" ","_")
                    subheader=sheet_data[sheet]['subcategories'][v]["subsection"]
                    doc.append(Command("subsection",subheader))
                    # doc.append(NoEscape("\\noindent\\rule{\\textwidth}{0.4pt}"))
                    doc.append(Command('fullline'))
                    p_y=''
                    p_m=''
                    monthit=len(sheet_data[sheet]['subcategories'][v]['data'])
                    p_title=''
                    p_entry={}
                    merge=0
                    for i in sheet_data[sheet]['subcategories'][v]['data']:

                        c_y = i['year'].replace(" ","")
                        c_m = i['month'].replace(" ","")
                        # this accounts for year/month repetition
                        if p_y != c_y and p_m != c_m:
                            # year and month changed, display full date
                            dateit=i['year']
                            if monthit > 1:
                                dateit+=" | " +i['month'][:3]

                        elif p_y == c_y and p_m != c_m:
                            # only month changed, display month only
                            dateit=i['month']
                        elif p_y != c_y and p_m == c_m:
                            # only year changed, display year only
                            dateit=i['year']
                        else:
                            # no change, no date display
                            dateit=''

                        p_y=c_y
                        p_m=c_m

                        # the current entry object
                        c_entry = {
                            "dates":i['dates'],
                            "title":i['title'],
                            "employer":i['employer'],
                            "description":i['description'],
                            "location":i['location'],
                            "subheader":subheader,
                            "year":i['year']
                        }

                        writeEntry(doc, dateit, c_entry)
                        
                        # this accounts for title repetition
                        # c_title = i['title'].replace(" ","")
                        
                        # first case (p_entry is empty)
                        # if not p_entry:
                        #     p_entry = c_entry
                        #     writeEntry(doc, dateit, c_entry)
                        # else:
                        #     # do titles differ ?
                        #     if p_title != c_title:

                        #         if merge:
                        #             writeEntry(doc, dateit, p_entry)
                        #             merge=0
                        #         else:
                        #             writeEntry(doc, dateit, c_entry)
                        #             p_entry = c_entry

                        #         # then update title
                        #         p_title = c_title
                        #     else:
                        #         # titles are the same
                        #         # we found two similar entries,
                        #         # merge them
                        #         for k,v in p_entry.items():
                        #             if p_entry[k] != c_entry[k]:
                        #                 p_entry[k] += ' and ' + c_entry[k]
                        #         merge=1
                        #         continue
                if "work" in sheet:
                    with doc.create(Section("Research Interests")):
                        for i in data["research"]:
                            doc.append(i+". ")
                    doc.append(Command("pagebreak"))
                # end subsection loop
            # end subsections
        # end sections
        with doc.create(Section("Other Skills")):
            doc.append(Command('fullline'))
            with doc.create(Itemize(options=[ 
                    'align=parleft',
                    'leftmargin=2.25cm',
                    'labelwidth=2cm' ]
                    )):
                doc.append(NoEscape("\\item[Languages]"))
                for i in data["languages"]:
                    doc.append(Command("textbf", i['item']))
                    doc.append(" ("+i['description']+") ")
                doc.append(NoEscape("\\item[Code]"))
                for i in data["code"]:
                    doc.append(Command("textbf", i['item']))
                    doc.append(" ("+i['description']+") ")
                doc.append(NoEscape("\\item[Software]"))
                for i in data["software"]:
                    doc.append(Command("textbf", i+"."))
    # end resume

    print("Compiling PDF file")
    doc.generate_pdf(clean_tex=True)

    doc.generate_tex()
